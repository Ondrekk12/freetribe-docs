{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Freetribe is a free, open-source firmware for Electribe 2, built from the ground up using original code and open-source projects. Freetribe aims to provide a user-friendly API for connecting control input to audio processing.</p> <p>See Getting Started to jump right into the Freetribe API.  See Features for an overview of what's included,  or Architecture for a deeper look at the system.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>Freetribe would be almost impossible without other open-source projects. The CPU drivers are based on StarterWare by Texas Instruments. The hardware abstraction, build environment and code examples provided the stepping-stone needed to get started.</p> <p>In much the same way, the DSP drivers are based on monome/aleph. This showed how to initialise the Blackfin processor and configure peripherals. They also provide a public domain DSP library, with many of the difficult maths problems packaged into convenient unit generators.</p> <p>MIDI input parsing is based on mikromodular/libmidi, with sysex/binary conversion borrowed from the Arduino MIDI library by Francois Best.</p> <p>UGUI and micromenu provide a graphical interface for user applications.</p> <p>Special thanks to countless stackoverflow users.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This section takes a deeper look at the Freetribe system architecture.</p>"},{"location":"architecture/#overview","title":"Overview","text":""},{"location":"architecture/#cpu","title":"CPU","text":""},{"location":"architecture/#hardware","title":"Hardware","text":""},{"location":"architecture/#hal","title":"HAL","text":""},{"location":"architecture/#peripheral","title":"Peripheral","text":""},{"location":"architecture/#device","title":"Device","text":""},{"location":"architecture/#service","title":"Service","text":""},{"location":"architecture/#kernel","title":"Kernel","text":""},{"location":"architecture/#user","title":"User","text":""},{"location":"architecture/#app","title":"App","text":""},{"location":"architecture/#dsp","title":"DSP","text":""},{"location":"architecture/#peripheral_1","title":"Peripheral","text":""},{"location":"architecture/#device_1","title":"Device","text":""},{"location":"architecture/#service_1","title":"Service","text":""},{"location":"architecture/#kernel_1","title":"Kernel","text":""},{"location":"architecture/#module","title":"Module","text":""},{"location":"building/","title":"Building an Application","text":"<p>This section describes the build process.</p>"},{"location":"building/#building-locally","title":"Building Locally","text":""},{"location":"building/#building-with-docker","title":"Building with Docker","text":"<p>We can run <code>make</code> in the container to build Freetribe.</p> <pre><code>docker compose exec freetribe make clean\ndocker compose exec freetribe make\n</code></pre> <p>The final binary will be at <code>freetribe/cpu/build/cpu.bin</code>.</p> <p>This includes the DSP firmware, which is sent to the Blackfin by the CPU, via SPI.</p> <p>I will add documentation for setting up the build environment locally, but you can probably work it out from the commands in the Dockerfile.</p>"},{"location":"building/#makefile-options","title":"Makefile Options","text":""},{"location":"debugging/","title":"Attaching a Debugger","text":"<p>See the Hacktribe Debrick Guide for more details on getting a debugger attached.</p>"},{"location":"debugging/#cpu","title":"CPU","text":"<p>For the CPU, a JLink EDU and JLinkGDBServer works well. We can also use a Raspberry Pi and OpenOCD.</p> <p>If using JLink, connect the debugger to USB host, then power electribe using modified power switch. Then run:</p> <pre><code>JLinkGDBServer -device am1802 -speed 0\n</code></pre> <p>If using Raspberry Pi, OpenOCD will exit if the electribe is not powered, but the electribe will boot if OpenOCD is not attached, so we need some trickery. First power up electribe, then run OpenOCD, then power off electribe with OpenOCD still running. Then power up electribe again before restarting OpenOCD. It is a lot easier to use a JLink.</p> <p>Once you have a gdb server attached to the CPU, change directory to <code>freetribe/cpu</code> and run:</p> <pre><code>arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>freetribe/cpu/.gdbinit</code> should connect to the gdb server, load the symbols from <code>cpu/build/cpu.elf</code> and run the firmware. You may need to edit the port number in <code>.gdbinit</code>. OpenOCD uses <code>3333</code> by default, with JLinkGDBServer using <code>2331</code>.</p> <p>If all is well, you should hit a breakpoint at <code>main</code>. Other useful breakpoints may be <code>knl_init</code>, <code>knl_run</code>, <code>app_init</code> and <code>app_run</code>.</p>"},{"location":"debugging/#dsp","title":"DSP","text":"<p>For the DSP, I've only managed to get the official debugger from Analog Devices working. The ADSP-ICE-1000 costs around \u00a3180 (thank you sponsors) and is very much a one-trick pony. I will try again to get the Raspberry Pi set up with the DSP, but I'm not sure if the Analog Devices OpenOCD fork is even supposed to support this.</p> <p>The good news is, the DSP firmware is loaded by the CPU. So if you can deal without debugging you can still load and run your code.</p> <p>If you have a debugger for the DSP, first run the binary on the CPU. By the time the CPU reaches <code>app_run</code> the DSP kernel will be running.</p> <p>Change directory to <code>freetribe/dsp</code> and run:</p> <pre><code>sudo openocd-bfin -s /usr/share/openocd-bfin/scripts \\\n                  -f /usr/share/openocd-bfin/scripts/interface/ice1000.cfg \\\n                  -f /usr/share/openocd-bfin/scripts/target/bf527.cfg\n</code></pre> <p>Then in another shell in the same directory:</p> <pre><code>bfin-elf-gdb\n</code></pre> <p>The commands in <code>freetribe/dsp/.gdbinit</code> should connect to the gdb server, load the symbols from <code>freetribe/dsp/build/bfin.elf</code> and set a breakpoint at <code>module_process</code>, the audio processing callback.</p> <p>I will try to add new sysex functions to Hacktribe, so we can load and execute code without needing a debugger.</p>"},{"location":"examples/","title":"Examples","text":"<p>The main demo uses the volume knob to control attenuation of audio pass-through, while sending MIDI CC and printing to the display. Recevied MIDI note messages are echoed to the output and an LED blinks at regular intervals. An external library is integrated for GUI management.</p> <p>Future examples will deal separately with individual features, building up to a more complex application.</p>"},{"location":"features/","title":"Features","text":"<p>From a user application perspective, Freetribe is currently light on features. Most of the hardware initialisation is complete, with driver stacks for much of the system. Built on this is a set of services providing a high-level interface to the device. Some basic examples are provided, showing how to integrate user application code with the Freetribe kernel.</p>"},{"location":"features/#cpu-kernel","title":"CPU Kernel","text":"<p>The CPU kernel initialises the hardware, processes communication with the outside world and controls the Blackfin DSP via a serial command interface.</p>"},{"location":"features/#midi-service","title":"MIDI Service","text":"<ul> <li>Serial MIDI input and output via TRS port.</li> <li>Register callbacks for each type of message received.</li> <li>Send simple messages such as note and CC.</li> </ul>"},{"location":"features/#display-service","title":"Display Service","text":"<ul> <li>Set or clear a pixel anywhere in the vast 128x64 dot-matrix.</li> <li>Control backlight RGB (binary).</li> </ul>"},{"location":"features/#panel-service","title":"Panel Service","text":"<ul> <li>Register callbacks for all of the panel controls.</li> <li>Set and toggle LEDs, with brightness control for those with support.</li> </ul>"},{"location":"features/#system-service","title":"System service","text":"<ul> <li>Aggregates useful things like print and timing.</li> </ul>"},{"location":"features/#dsp-service","title":"DSP Service","text":"<ul> <li>Send commands to the Blackfin DSP and receive feedback.</li> </ul>"},{"location":"features/#dsp-kernel","title":"DSP Kernel","text":"<p>The DSP kernel receives commands from the CPU and processes audio frames. A user defined module runs in the audio callback, with an interface similar to many plugin formats.</p>"},{"location":"features/#planned-features","title":"Planned Features","text":"<p>Some of these are in progress, most should be possible.</p>"},{"location":"features/#high-speed-dsp-control","title":"High speed DSP Control","text":"<ul> <li>CPU EMIFA is connected to DSP HostDMA with a 16 bit parallel interface.</li> <li>(Currently Freetribe uses SPI to control DSP).</li> </ul>"},{"location":"features/#dma-driver","title":"DMA Driver","text":"<ul> <li>Implement CPU DMA driver and update device drivers.</li> </ul>"},{"location":"features/#usb-driver","title":"USB Driver","text":"<ul> <li>Port TinyUSB.</li> </ul>"},{"location":"features/#sd-card-driver","title":"SD Card Driver","text":"<ul> <li>Port FatFS.</li> </ul>"},{"location":"features/#dsp-block-processing","title":"DSP Block Processing","text":"<ul> <li>Implement block processing using DMA linked descriptors.</li> </ul>"},{"location":"features/#cache-and-memory-protection","title":"Cache and Memory Protection","text":"<ul> <li>Currently everything runs in system mode with no cacheing.</li> </ul>"},{"location":"features/#dynamic-linking","title":"Dynamic Linking","text":"<ul> <li>CPU app and DSP module are currently compiled into the kernels.</li> <li>Implement as DLL to allow runtime switching of apps/modules/plugins.</li> </ul>"},{"location":"features/#preemptive-scheduling","title":"Preemptive Scheduling","text":"<ul> <li>Port FreeRTOS.</li> </ul>"},{"location":"features/#micropython","title":"MicroPython","text":"<ul> <li>As FreeRTOS task.</li> </ul>"},{"location":"features/#sync-ports","title":"Sync Ports","text":"<ul> <li>Probably debounced GPIO, haven't checked.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section shows how to get started with the Freetribe API.  The minimal example code shows how to blink an LED on the panel  using the Freetribe API's non-blocking delay function. </p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before we can actually run our app, we will need to  install the toolchain and attach a debugger. For now, we can work in a codespace on Github,  and continue with this section to get an idea of how the Freetribe API works.  </p> <p>Create a codespace on the <code>main</code> branch of the Freetribe Github repo, then create a directory for the app and a file for the code:</p> <pre><code>mkdir cpu/src/apps/blink\ntouch cpu/src/apps/blink.c\n</code></pre> <p>Open <code>blink.c</code> in the editor of your choice.  The codespace includes VSCode and neovim.</p>"},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<p>First, we must include the Freetribe API:</p> <pre><code>#include \"freetribe.h\"\n</code></pre> <p>This gives us access to all the functions our  application should need for interacting with the device.</p> <p>Next, there are 2 functions we should override. The first, <code>app_init()</code>, runs once when our app starts.  This is a good place to register callbacks for events we are interested in,  and do any initialisation required by external libraries.</p> <p>In this example, we initialise a static global variable to hold the start time of our delay.  The <code>app_init()</code> function takes no arguments and returns <code>t_status</code>, an integer error code.</p> <pre><code>// 1 second in microseconds.\n#define DELAY_TIME 1000000 \n\nstatic uint32_t g_start_time; \n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n</code></pre> <p></p> <p>The second function, <code>app_run()</code>, is called continuously in the main loop,  after <code>app_init()</code> has completed.  In this example, we toggle an LED on the panel if 1 second has passed,  and reset the delay start time. </p> <p>The <code>app_run</code> function takes no arguments and returns nothing.</p> <pre><code>void app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre> <p>This is all the code we need to blink an LED at regular intervels,  everything else is taken care of by the Freetribe kernel.  It is important that any code we write is non-blocking, as everything  is running in the same loop as the kernel. The full listing of <code>blink.c</code> is reproduced at the bottom of this page. </p>"},{"location":"getting-started/#building","title":"Building","text":"<p>Build with <code>make</code>, passing the name of our app directory in the APP environment variable:</p> <pre><code>make clean &amp;&amp; make APP=blink\n</code></pre> <p>There will be a lot of warnings about incompatible types and implicit declarations, but there should be no errors. See Buiding an Application for more information about the build system.</p>"},{"location":"getting-started/#output-files","title":"Output Files","text":"<p>The final output file, <code>freetribe/cpu/build/cpu.elf</code>, includes the CPU kernel and our app. It also includes the DSP kernel and audio processing module, as an array sent to the DSP during boot. We will explore the other files in this directory in future tutorials.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Once you have set up the toolchain, move on to attaching a debugger  to see how to run this simple example app. After that, work through the Freetribe Tutorial to explore more of the Freetribe API.</p>"},{"location":"getting-started/#blinkc","title":"<code>blink.c</code>","text":"<pre><code>// Freetribe: Minimal Example\n// License: AGPL-3.0-or-later\n\n#include \"freetribe.h\"\n\n// 1 second in microseconds.\n#define DELAY_TIME 1000000 \n\nstatic uint32_t g_start_time; \n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n\nvoid app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre>"},{"location":"license/","title":"License","text":"<p>AGPL-3.0-or-later.</p>"},{"location":"support/","title":"Support","text":""},{"location":"support/#support-for-you","title":"Support for You","text":"<p>If you need help with this project, please visit the  Freetribe discussion forum  on Github.</p>"},{"location":"support/#support-for-me","title":"Support for Me","text":"<p>Freetribe is free (as in GPL) and always will be. If you would like to support my work you are most welcome to  become a sponsor. Freetribe exists because people sponsored Hacktribe. Your support helps keep me motivated, fuelled and focussed.</p>"},{"location":"toolchain/","title":"Installing the Toolchain","text":"<p>This section describes how to install the toolchain for building and debuggong Freetribe applications. See Building an Application for more details on the build system, and Attaching a Debugger for how to run and debug an application.</p>"},{"location":"toolchain/#installing-locally","title":"Installing Locally","text":""},{"location":"toolchain/#installing-with-docker","title":"Installing with Docker","text":"<p>If you have <code>docker compose</code> installed on your local machine, change to the <code>freetribe</code> directory and build the docker image:</p> <pre><code>docker compose build\n</code></pre> <p>Then start a container:</p> <pre><code>docker compose up -d\n</code></pre> <p>The current working directory will be mounted in the container at <code>/freetribe</code>.</p>"},{"location":"tutorial/","title":"Freetribe Tutorial","text":"<p>Visit the Freetribe Tutorial  for a series of  examples demonstrating features of the Freetribe API. Each example builds on the last, moving from a simple blinking LED,  to a more complex application with user input, audio processing, MIDI handling and feedback to the display.</p>"}]}